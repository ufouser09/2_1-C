/* 
uygulama-3
bir hastanenin acil servisinde kullanılmak üzere bir kuyruk hazırlanacaktır.
kuyruk hastaların sıralarını takip edebilmesi için kullanılacaktır.

hastalar hastaneye kayıt yaptırmak için isim,soy isim,TC kimlik numarası ve yaş bilgilerini paylaşmalıdır.

hastanelerde vakalar acil vaka olarak incelenmektedir.
bu dogrultuda asagıdaki ilkeleri gercekleyen kuyruk modelini olusturun.

1-yeni bir hasta geldiginde eger acil bir vaka degilse dogrudan kuyruga eklenmelidir.
asagıdaki ornekte ilk olarak 1'inci hasta gelir ardından 2,3,4 ve 5'inci hastalar gelir.

1...2...3...4...5

2-oncelikli bir hasta geldiginde ise listedeki son oncelikli hastadan sonraki sıraya yerlestırılmelidir.
listede hiç öncelikli hasta olmadıgında eklenecek oncelikli hasta listenin basına eklenir.6'ıncı hasta onceliklidir ve listenin basına eklenmistir.

6...1...2...3...4...5

ardından yeni bir oncelikli vaka geldiginde kuyruk asagıdaki gibi olmalıdır.

6...7...1...2...3...4...5

3-hastalar doktora gorunmekten vazgectıklerınde kuyruktan cıkarılmalıdır.
3'uncu hasta,hasta ismi kullanılarak kuyruktan cıkarılmıstır.

6...7...1...2...4...5

4-kuyrukta bulunan hastaların bilgileri dosyada tutulmalıdır.

5-istenildiginde kuyrukta bekleyenlerin bilgileri dosyadan okunmalıdır.

*/
//-----bu dosyanın adı uygulama.c main kodumuz burda yazılıyor.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "struct_patient.h"
#include "file_opr.c"

#define MAX_SIZE 20
#define WARNING "malloc failed!"




Patient_Node* create_new_patient();
void insert_patient_to_list(Patient_Node *new_node,Patient_Node **head);
void delete_patient(char *name,Patient_Node **head);

//yeni hasta olusturma fonksiyonunda da öncelikle yeni bir node olusturuyoruz.
Patient_Node* create_new_patient(){
	Patient_Node *new_node;
	
//-----allocation memory for new patient
	new_node=(Patient_Node*)malloc(sizeof(Patient_Node));
	
	if(new_node==NULL){
		printf(WARNING);
		exit(1);
	}
	//kullanıcıdan verileri alıyoruz.
	//getting inputs from user
	printf("\nPlease enter patient informations...\n");
	printf("Name  :");
	scanf("%s",new_node->data.name);
	printf("surname:");
	scanf("%s",new_node->data.surname);
	printf("ID   :");
	scanf("%s",new_node->data.ID);
	printf("Age   :");
	scanf("%d",&new_node->data.age);
//-----asagıdaki printf'de patient'ın önceliği varsa 1 degerini alır eger onceliği yoksa 0 degerini alır diyor.
	printf("if patient has a priorty enter 1 otherwise enter 0 for prior..\n");
	printf("prior :");
	scanf("%d",&new_node->data.prior);
	new_node->next=NULL;
//-----ve sonra yeni bir node olusturuyoruz.bu olusturdugumuz node insert_patient_to_list fonksiyonuna bi parametre olarak gidiyor yani
	return new_node;
	
} 
//this function is used for inserting new patient to list.
//-----eklemek istedigim zaman buraya geliyorum.yeni bir hasta eklemek istedigim zaman bu fonksiyonu kullanıyorum.

//-----şimdi new_node ve head parametremizi kullanarak şimdi bir ekleme yapıcaz.
void insert_patient_to_list(Patient_Node *new_node,Patient_Node **head){
//-----if head equals to NULL,new patient will be the head of list.
//-----şimdi bizim listemizde su anda bosken hiçbir head'imiz yok link list'in basını ifade eden bir node'umuz yok.o zaman ben ne eklersem ekliyim bu benim listemin bası olucak.o yuzden head ifadem yani listenin basını ifade eden degiskenim eger NULL ise direk priority'si var mı yok mu kontrol etmeden direk o hastayı listenin bası olarak esitliyorum.ve ekleme fonksiyonumdan geri donuyorum.
//-----bu arada en basta node'umuzun head'ini olusturuyoruz yukarıda ve bu head'i global bir degisken olarak degilde fonksiyonlarımıza parametre olarak gönderiyoruz.mesela yukarıda patient_node'un head pointer'ını olusturmusuz.ekleme fonksiyonumuzda adresiyle gönderiyoruz case 1'de.parametre olarak da case1'de create_new_patient()fonksiyonunu alıyor.
	
//-----liste tamamen bossa eklememizi asagıdaki gibi yaptık.
		if((*head)==NULL){
			(*head)=new_node;
			return;
		}
//-----liste tamamen bos degilse yani bir head'imiz varsa nasıl ilerlicez
		Patient_Node *var_head=(*head);
		Patient_Node *last_prior=(*head);
		Patient_Node *temp;
		
//-----check the new patient priorty,has it high priorty.
//-----sonra kotrol ediyoruz bu yeni hastanın prioritisini eger prioritisini 0 dan farklı derse zaten prioritimiz için öncelik yoksa 0 onceligi varsa da 1 degerini alır.eger hasta olustururken patient'ın önceligi var ise 1 degeri giricez.onceligi yok ise 0 degeri giricez.kullanıcıdan daha veriyi alirken.
//-----ondan sonra burda kontrol ediyoruz eger hastanın priritisi var ise
		if(new_node->data.prior !=0){
			
//-----buraya geliyoruz ne diyor.yani bastan kontrol edicez listenin basında prioritisi olan bir hasta var mı varsa o benim ilk last_prioriti diye bir degiskenim var ya ona esit olucak eger ondan sonraki node da prioritisi 1 ise bu sefer last_prior'imi ikinciye esitlicem yani 1.indextte bulunan hastaya işaretlemiş olucam.bir sonrakininde prioritisi yuksek ise bu sefer 3.eleman benim prioritisi yuksek olan hastam olucak yani last priorim olucak çünkü onun ardına ekleme yapıcam ya o yuzden listedeki en uctakı .bu işlemde bunu yapıyorum.
//-----detect the last patient with high priorty.
//-----priority için önceliği yoksa 0 onceliği varsa da 1 degerini alıcak.
			while(var_head != NULL){
				if(var_head->data.prior !=0){
					last_prior=var_head;
				}
					var_head=var_head->next;
				
				
			}
			
			
			
			
			
			//yukarıdaki işlemi yaptıktan sonra öncelikle sunu yapıyoruz.bakalım hala head yani listenin basındaki ifade last prior mu yoksa degisti mi bu diye bunu kontrol ediyoruz.eger last_prior hala listenin basındaki ifadeye esitse o zaman sunu kontrol ediyorum 
			//we set the initial last prior as head node.
			//check is the last prior still head of the still.
			if(last_prior==(*head)){
				
				
				//if head of least has not high priorty,new patient will be head of list.
				//listenin basındaki elemanın prioritisi var mı yok mu cunku biz initial olarka biz last_prior'u yukarıda head olarak işaretledik.yani listede hiç prioritisi olan hasta yoksa bu hala head olarak kalmıs olucak listede e öyle olunca da eklememizi biz head'in sonrasına yapıcak şekilde ayarlamıstık.yani last prioritinin bi sonrasina ekleme yapıcaz.ve last prior head'e esitse ve head'in prioritisi yoksa o zaman orda bir karısıklık olucak.yani bir tane onceliksiz hasta sonra öncelikli hasta sonra önceliksiz hasta diye devam edicek sekilde bir sıkıntı yasıyabiliriz.bunu kontrol altına almak için de bunu kontrol ediyoruz.last prior hala head'e esit mi eger head'e esitse napıcaz oncelikli hastayı ben yeni head yapıcaz ama eger head'e esit degilse last_prior o zaman elde ettiğim last_prior'un bir sonrakine ekleme yapıcaz.
			if((*head)->data.prior==0){
				//head'in degerini bir temprorary degiskende tutuyoruz.
				temp=(*head);
				//sonra yeni head'imiz new_node oluyor.yani yeni hastamız öncelikli olan hastamız sonra yeni nodun bi sonra işaret ettiği node da temproray de tuttugumuz eski listenin bası olucak.eger tam tersi ise yani head'e esit degilse o zaman bir sonraki işaret ettiği veriye yeni hastayı ekliycez. 
				(*head)=new_node;
				new_node->next=temp;
			}
			else{
				//else,new patient will be added after the last prior.
				//last prior'ın işaret ettiği bir sonraki ifadeyi temp te tutuyorum sonra last_prior'ın bi sonra işaret ettiği yere yeni hastamı ekliyorum sonra yeni hastanın işaret ettiği yere de bir onceki temp te tuttugum degeri eklemis oluyorum.
				temp=last_prior->next;
				last_prior->next=new_node;
				new_node->next=temp;
			}	
			
			}
			else{
				//burda da else durumu bu neyin else'i
				//eşit degilse yine burda da ekleme yapıcaz
				//else,new patient will be added after the last prior.
				temp=last_prior->next;
				last_prior->next=new_node;
				new_node->next=temp;
			}
		}
		//bu hasta prioritisi olmayan bir hasta ise o zaman napıcaz direk listenin son elemanını bulucaz.asagıdaki while sayesinde   
		else{
			while(var_head->next!=NULL){
				var_head=var_head->next;
			}
			var_head->next=new_node;
		}

	
}
//hastaları isimleri ile birlikte silicez.aslında tc numaralarıyla silmek daha iyi olurdu çunku birden fazla ahmet olabilir.
//parametre olarak hem ismi alıyo hem de listenin basını alıcak haliyle çunku listede arama yapıcaz ismini buldugumuz hastayı silicez listeden.
void delete_patient(char *name,patient_Node **head){
	//su anda patient'in tuttugu veri null var_head'de bizim listemizin basını isaret ediyor.
	//var_head null olana kadar biz listede arama yapıyoruz.
	//strcmp komutu eger 0 donerse iki stringin birbirine esit oldugunu ifade ediyor.
	//var head'in ismiyle var head'in işaret ettigi data'nın ismini ve bizim kullanıcıdan aldıgımız ismi compare ediyoruz.eger bu deger 0'a esitse fonksiyonun return'u bu hastayı bulduk demektir.sonra patient'i var_head'e eşitliyoruz.çünkü buldugumuz hastanın bilgileri hepsi burda tutulmus.
	//sonra bu dongu bittigi zaman patient artık arama yaptıgımız isimdeki hastanın bilgilerini tutuyor.o zmaan napıcaz sunu kontrol ediyoruz.buldugumuz hasta listenin basındaki hasta mı degil mi ona bakıyoruz.eger basındaki hasta ise yeni head'imiz head'in bi sonra işaret ettiği hasta olucak ama eger bas degil ise
	Patient_Node *patient=NULL,*var_head;
	var_head=(*head);
	while(var_head !=NULL){
		//if patient's name and entered name is equal,variable patient keeps patient that will delete.
		if(strcmp(var_head->data.name,name)==0)//0 means,two string is equal.
		patient = var_head;
		
		var_head=var_head->next;
	}
	//if patient is the head of list,new head will be the head->next.
	if(patient ==(*head)){
		(*head)=(*head)->next;//artık head dedigimiz yer onceden headin gosterdigi yer
		
	}
	else{
		//patient'ın null olup olmadıgını kontrol ediyoruz çünkü hiç listede olmayan bir eleman da olabilir. eger oyleyse zaten listede bulunamadı diye print ediyoruz ve donuyoruz.eger boyle bir durum yoksa listede buluyoruz bu degiskeni ve hastayı napıyoruz o node'u aradan cıkartıyoruz yani var_head'in next'i o hastanın nextinin nextine işaret ediyor
		//if patient is NULL,there is no patient in list with entered name.
		if(patient==NULL){
			printf("\nCould not find the element with %s",name);
			return;
		}
		var_head=(*head);
		//finding patient in list.
		while(var_head->next !=patient){
			var_head=var_head->next;
		}
		//yani burda tekrar arama yapmamızını sebebi su patient'tan onceki aslında  bizim buldugumuz patient'ı bır onceki node'a set ediyoruz.var_head'in next'i patient olana kadar bu dongu calısacak oldugu anda burdan cıkacak yani bu aslında wihle ' girmeyip silmek istedigim nodun bir onceki nodu aslında yani dolayısıyla var_head'in işaret ettigi bi sonraki işaret ettirmek istedigim verinin yerine işaret ettigi nodun bi sonra isaret ettiğini almıs olucam(31.29) 
		//when we delete the patient,previous node's next node will be the patient's next node.
		var_head->next=var_head->next->next;
		free(patient);
	}
}

//-----oncelikle main'de biz napıcaz kac tane işlemimiz var.
//-----kullanıcı girebilicez.ya da hasta ekliycez kuyruga,
//-----ondan sonra ismiyle bu hastayı silebilicez.
//-----sonra ben her istedigimde dosyadan bu listeyi print edebilicem.
//-----3 tane ana işlemimiz var.ekleme yapma çıkarma yapma ve 
//-----görüntüleme bunlar için bir dongu olusturmusuz.
//-----her seferinde kullanıcıdan eklemek istiyorsa 1-silmek istiyorsa
//----- 2-print etmek istiyosa da 3 verisini alarak okuyarak secimlerimizi bu sefer switch case yapısı ile degerlendiriyoruz.
int main(){
	char name[MAX_SIZE];
	int choose=1;
	
//-----head node specify the head of list.
	Patient Node *head=NULL;
	
	while(choose>0){
		printf("\nFor entering new patient press 1..\n");
		printf("For deleting patient with name press 2..\n");
		printf("For reading list from the file press 3..\n");
		printf("For exit press 0..\n");
		printf("\nPlease enter your choice:");
		scanf("%d",&choose);
		case 1:
//-----eklemek istedigim zaman ben asagıdaki fonksiyonu çalıstırıyormusum.
			insert_patient_to_list(create_new_patient(),&head);
			printListWithAllInformations(&head);
			break;
			
			case 2:
				printf("\nEnter patient name that want to delete:");
				scanf("%s",name);
				delete_patient(name,&head);
				printListWithAllInformations(&head);
				break;
				
				
					case 3:
						read_file();
						break;
	}
}
return 0;
//31.29
